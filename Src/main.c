/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32l432xx.h>

#include <math.h>
#include <tone.h>
#include <gpio.h>

// PB3 is a replacement for the unconnected PF1
const uint8_t led[] = {PB0, PB1, PA8, PB3, PB5, PB4, PA1, PA0};

const uint8_t button[2] = {PA6, PA5};

// buzzer and analog (ADC) are swapped compared to old F0
const uint8_t buzzer = PA3; // TIM15 CH2 (AF14)

const uint8_t analog = PA4; // ADC1_IN4

#define NOTE_F4  349
#define NOTE_A4  440
#define NOTE_C5  523
#define NOTE_E5  659
#define NOTE_F5  698

void imperial_march() {
  static const int melody[] = {NOTE_A4, NOTE_A4, NOTE_A4, NOTE_F4, NOTE_C5, NOTE_A4, NOTE_F4, NOTE_C5, NOTE_A4, NOTE_E5, NOTE_E5, NOTE_E5, NOTE_F5, NOTE_C5, NOTE_A4, NOTE_F4, NOTE_C5, NOTE_A4};
  static const int durations[]  = {4, 4, 4, 5, 16, 4, 5, 16, 2, 4, 4, 4, 5, 16, 4, 5, 16, 2};
  int bpm = 120;

  for(unsigned int i=0; i<sizeof(melody)/sizeof(melody[0]); ++i ) {
    uint32_t freq = melody[i];
    uint32_t ms = roundf((1000.0f * 60 * 4) / (bpm * durations[i]));
    tone(freq, ms);
  }
}


// route SYSCLK to MCO pin PA8
void init_MCO(void) {
    //RCC->CFGR = (RCC->CFGR &~RCC_CFGR_MCOPRE_Msk) | (0 << RCC_CFGR_MCOPRE_Pos); // MCO divided by 2^0 == 1
    //RCC->CFGR = (RCC->CFGR &~RCC_CFGR_MCOPRE_Msk) | (3 << RCC_CFGR_MCOPRE_Pos); // MCO divided by 2^3 == 8
    RCC->CFGR = (RCC->CFGR &~RCC_CFGR_MCOPRE_Msk) | (4 << RCC_CFGR_MCOPRE_Pos); // MCO divided by 2^4 == 16
    RCC->CFGR = (RCC->CFGR &~RCC_CFGR_MCOSEL_Msk) | (1 << RCC_CFGR_MCOSEL_Pos); // SYSCLK -> MCO

    // PA8 AF0 -> MCO
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN; // enable clock for peripheral component 
    (void)RCC->AHB2ENR;                  // ensure that the last write command finished and the clock is on
    GPIOA->AFR[1] = (GPIOA->AFR[1] &~GPIO_AFRH_AFSEL8_Msk) | (0 << GPIO_AFRH_AFSEL8_Pos);           // AF 0 
    GPIOA->MODER = (GPIOA->MODER &~GPIO_MODER_MODE8_Msk) | (2 << GPIO_MODER_MODE8_Pos);             // AF mode
    GPIOA->OSPEEDR = (GPIOA->OSPEEDR &~GPIO_OSPEEDR_OSPEED8_Msk) | (3 << GPIO_OSPEEDR_OSPEED8_Pos); // very high speed 
}


int main(void)
{
  SystemClock_Config();
  init_MCO();
  
    for(int i=0; i<8; ++i)
        gpio_output(led[i]);

    for(int i=0; i<8; ++i)
        gpio_set_1(led[i]);

    imperial_march();

    /* Loop forever */
	for(;;);
}
